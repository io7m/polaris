#
# Copyright © 2017 <code@io7m.com> http://io7m.com
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
# IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

EXPECTED_EXPRESSION_BUT_GOT_DECLARATION                         = An expression
EXPECTED_KEYWORD                                                = A keyword:
EXPECTED_TERM_NAME_UNQUALIFIED_GOT_EXPRESSION                   = An unqualified term name
EXPECTED_TERM_REFERENCE_GOT_EXPRESSION                          = A term reference
EXPECTED_TYPE_NAME_UNQUALIFIED_GOT_EXPRESSION                   = An unqualified type name
EXPECTED_TYPE_REFERENCE_GOT_EXPRESSION                          = A type reference
INVALID_APPLICATION                                             = (<term-constructor-name> { <expression> })
INVALID_CONSTRUCTOR_NAME                                        = A valid constructor name matching the pattern:
INVALID_CONSTRUCTOR_REFERENCE                                   = [ <unit-name> : ] <term-constructor-name>
INVALID_FUNCTION                                                = (define-function <term-name> ({ <term-name> }) <expression>)
INVALID_FUNCTION_DUPLICATE_PARAMETER                            = Function parameters to be uniquely named
INVALID_INTEGER                                                 = A valid integer
INVALID_LAMBDA                                                  = (lambda ({ <term-name> }) <expression>)
INVALID_LAMBDA_DUPLICATE_PARAMETER                              = Lambda parameters to be uniquely named
INVALID_LOCAL                                                   = (local { <expression-or-declaration> } <expression>)
INVALID_MATCH                                                   = (match <expression> { <match-case> })
INVALID_MATCH_CASE                                              = (case <pattern> <expression>)
INVALID_PACKAGE_NAME                                            = A valid package name matching the pattern:
INVALID_PATTERN                                                 = <real> | <integer> | <term-name> | (<term-name> <term-name>) | _
INVALID_PATTERN_EXPECTED_CONSTRUCTOR_REFERENCE                  = A reference to a constructor
INVALID_PATTERN_EXPECTED_CONSTRUCTOR_UNQUALIIFIED_ARGUMENT_NAME = An unqualified name as the constructor argument
INVALID_REAL                                                    = A valid real number
INVALID_RECORD                                                  = (define-record <type-constructor-name> [ (for-all { <type-variable-name> }) ] { <field> })
INVALID_RECORD_DUPLICATE_FIELD                                  = Field names to be unique within the record type
INVALID_RECORD_FIELD                                            = (field <term-name> <type-expression>)
INVALID_S_EXPRESSION                                            = A well-formed S-expression: <symbol> | <quoted-string> | ({ <expression> })
INVALID_TERM_CONSTRUCTOR_NAME                                   = A valid term constructor name matching the pattern:
INVALID_TERM_NAME                                               = A valid term name matching the pattern:
INVALID_TYPE_CONSTRUCTOR_NAME                                   = A valid type constructor name matching the pattern:
INVALID_TYPE_EXPRESSION                                         = <type-reference> | <type-application> | <type-forall>
INVALID_TYPE_EXPRESSION_ARROW                                   = (→ { <type-expr> } [ <type-expr-variadic> ] <type-expr>)
INVALID_TYPE_EXPRESSION_FORALL                                  = (∀ <type-name> { <type-name> } <type-expression>)
INVALID_TYPE_EXPRESSION_FORALL_DUPLICATE_NAME                   = Type parameter names to be unique within the for-all
INVALID_TYPE_EXPRESSION_UNEXPECTED_VARIADIC                     = A non-variadic type parameter
INVALID_TYPE_EXPRESSION_VARIADIC                                = (… <type-expr>)
INVALID_TYPE_SIGNATURE                                          = (: <term-name> <type-expr>)
INVALID_TYPE_VARIABLE_NAME                                      = A valid type variable name matching the pattern:
INVALID_UNIT                                                    = (define-unit <unit-name-qualified>)
INVALID_UNIT_IMPORT                                             = (import <unit-name-qualified>)
INVALID_UNIT_IMPORT_QUALIFIED                                   = (import-qualified <unit-name-qualified> <unit-name>)
INVALID_UNIT_EXPORT_TERMS                                       = (export-terms <term-reference> {<term-reference>})
INVALID_UNIT_EXPORT_TERMS_DUPLICATE_NAME                        = Exported term names to be unique within the export declaration
INVALID_UNIT_EXPORT_TYPES_DUPLICATE_NAME                        = Exported type names to be unique within the export declaration
INVALID_UNIT_EXPORT_TYPES                                       = (export-types <type-constructor-name> {<type-constructor-name>})
INVALID_UNIT_NAME                                               = A valid unit name matching the pattern:
INVALID_VALUE                                                   = (define-value <term-name> <expression>)
INVALID_VARIANT                                                 = (define-variant <type-constructor-name> [ (for-all { <type-variable-name> }) ] { <field> })
INVALID_VARIANT_CASE                                            = (case <term-constructor-name> [ <type-expression> ])
INVALID_VARIANT_DUPLICATE_CASE                                  = Case names to be unique within the record type
